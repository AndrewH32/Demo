<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sol-Hearts</title>
    <link rel="stylesheet" href="Sol-Hearts-Styles.css"> <!-- Link to custom CSS file for styling -->
    <style>
        /* Define any additional CSS styles for your canvas or other elements here */
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto; /* Center the canvas */
        }

        /* Center the PDF within its container */
        .pdf-container {
            width: 800px; /* Adjust the width as needed */
            height: 600px; /* Adjust the height as needed */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pdf-container iframe {
            width: 100%;
            height: 100%;
            display: block;
            margin: auto; /* Center the PDF within the container */
        }
    </style>
</head>
<body>
    
    <header>
        <h1>Sol-Hearts</h1>
        <nav>
            <ul>
                <li><a href="#design">Design Document</a></li>
                <li><a href="#game">Game</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <section id="design">
        <h2>Design Document</h2>
        <div class="pdf-container">
            <iframe src="Sol Hearts.pdf" title="Sol-Hearts" frameborder="0"></iframe>
        </div>
    </section>

    <section id="game">
        <h2>Game</h2>
        <!-- Canvas for the game -->
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </section>
<script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const spaceImg = new Image();
        spaceImg.src = 'imgs/space.jpg';

        const trackImg = new Image();
        trackImg.src = 'imgs/track.png';

        const trackBorderImg = new Image();
        trackBorderImg.src = 'imgs/track-border.png';

        const finishImg = new Image();
        finishImg.src = 'imgs/finish.png';

        const greenRocketImg = new Image();
        greenRocketImg.src = 'imgs/green-rocket.png';

        const orangeRocketImg = new Image();
        orangeRocketImg.src = 'imgs/orange-rocket.png';

        const WIDTH = trackImg.width;
        const HEIGHT = trackImg.height;

        let level = 1;
        const LEVELS = 10;

        const PATH = [
            [175, 119], [110, 70], [56, 133], [70, 481], [318, 731],
            [404, 680], [418, 521], [507, 475], [600, 551], [613, 715],
            [736, 713], [734, 399], [611, 357], [409, 343], [433, 257],
            [697, 258], [738, 123], [581, 71], [303, 78], [275, 377],
            [176, 388], [178, 260]
        ];

        class GameInfo {
            constructor(level = 1) {
                this.level = level;
                this.started = false;
                this.levelStartTime = 0;
            }

            nextLevel() {
                this.level++;
                this.started = false;
            }

            reset() {
                this.level = 1;
                this.started = false;
                this.levelStartTime = 0;
            }

            gameFinished() {
                return this.level > LEVELS;
            }

            startLevel() {
                this.started = true;
                this.levelStartTime = Date.now();
            }

            getLevelTime() {
                if (!this.started) return 0;
                return Math.round((Date.now() - this.levelStartTime) / 1000);
            }
        }

        class Car {
            constructor(maxVel, rotationVel) {
                this.img = null;
                this.maxVel = maxVel;
                this.vel = 0;
                this.rotationVel = rotationVel;
                this.angle = 0;
                this.x = 0;
                this.y = 0;
                this.acceleration = 0.1;
                this.startPos = [0, 0];
            }

            rotate(left = false, right = false) {
                if (left) {
                    this.angle += this.rotationVel;
                } else if (right) {
                    this.angle -= this.rotationVel;
                }
            }

            draw(win) {
                // Implement drawing logic here
            }

            moveForward() {
                this.vel = Math.min(this.vel + this.acceleration, this.maxVel);
                this.move();
            }

            moveBackward() {
                this.vel = Math.max(this.vel - this.acceleration, -this.maxVel / 2);
                this.move();
            }

            move() {
                const radians = Math.radians(this.angle);
                const vertical = Math.cos(radians) * this.vel;
                const horizontal = Math.sin(radians) * this.vel;
                this.y -= vertical;
                this.x -= horizontal;
            }

            collide(mask, x = 0, y = 0) {
                // Implement collision detection logic here
            }

            reset() {
                [this.x, this.y] = this.startPos;
                this.angle = 0;
                this.vel = 0;
            }
        }

        class PlayerCar extends Car {
            constructor() {
                super(10, 0.25);
                this.img = greenRocketImg;
                this.startPos = [180, 200];
            }

            reduceSpeed() {
                this.vel = Math.max(this.vel - this.acceleration / 2, 0);
                this.move();
            }

            bounce() {
                this.vel = -this.vel;
                this.move();
            }
        }

        class ComputerCar extends Car {
            constructor(maxVel, rotationVel, path = []) {
                super(maxVel, rotationVel);
                this.img = orangeRocketImg;
                this.startPos = [150, 200];
                this.path = path;
                this.currentPoint = 0;
            }

            drawPoints(win) {
                // Implement drawing points logic here
            }

            draw(win) {
                super.draw(win);
                // this.drawPoints(win);
            }

            calculateAngle() {
                // Implement angle calculation logic here
            }

            updatePathPoint() {
                // Implement path point update logic here
            }
        }

        Math.radians = function(degrees) {
            return degrees * Math.PI / 180;
        };

        window.onload = function() {
            // Draw images onto the canvas
            ctx.drawImage(spaceImg, 0, 0);
            ctx.drawImage(trackImg, 0, 0);

            // Initialize game objects
            const playerCar = new PlayerCar();
            const computerCar = new ComputerCar();

            // Start the game loop
            requestAnimationFrame(gameLoop);
        };

        function gameLoop() {
            // Update game state
            // Implement game logic here

            // Draw game objects
            // Implement drawing logic here

            // Request next frame
            requestAnimationFrame(gameLoop);
        }
    </script>

    <footer id="contact">
        <h2>Contact</h2>
        <p>Contact us at solhearts@example.com</p>
    </footer>
</body>
</html>

           
