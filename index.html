<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sol-Hearts</title>
    <link rel="stylesheet" href="Sol-Hearts-Styles.css"> <!-- Link to custom CSS file for styling -->
    <style>
        /* Define any CSS styles for your canvas here */
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto; /* Center the canvas */
        }
    </style>
</head>
<body>
    
    <header>
        <h1>Sol-Hearts</h1>
        <nav>
            <ul>
                <li><a href="#design">Design Document</a></li>
                <li><a href="#game">Game</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <section id="design">
        <h2>Design Document</h2>
        <iframe src="Sol Hearts.pdf" title="Sol-Hearts" width="800" height="600" frameborder="0"></iframe>
    </section>

    <section id="game">
        <h2>Game</h2>
        <!-- Canvas for the game -->
        <canvas id="gameCanvas" width="800" height="600"></canvas>
      <script>
const pygame = require('pygame');
const { get } = require('inputs');
const time = require('time');
const math = require('math');
const { scale, blit, rotate, center, text } = require('utils');

pygame.font.init();

const SPACE = scaleImage(pygame.image.load("imgs/space.jpg"), 2.5);
const TRACK = scaleImage(pygame.image.load("imgs/track.png"), 0.9);
const TRACK_BORDER = scaleImage(pygame.image.load("imgs/track-border.png"), 0.9);
const TRACK_BORDER_MASK = pygame.mask.fromSurface(TRACK_BORDER);
const FINISH = pygame.image.load("imgs/finish.png");
const FINISH_MASK = pygame.mask.fromSurface(FINISH);
const FINISH_POSITION = [130, 250];
const GREEN_ROCKET = scaleImage(pygame.image.load("imgs/green-rocket.png"), 0.25);
const ORANGE_ROCKET = scaleImage(pygame.image.load("imgs/orange-rocket.png"), 0.25);

const [WIDTH, HEIGHT] = [TRACK.getWidth(), TRACK.getHeight()];
const WIN = pygame.display.setMode([WIDTH, HEIGHT]);
pygame.display.setCaption("Sol Hearts!");
const MAIN_FONT = pygame.font.SysFont("comicsans", 44);
const FPS = 60;

const PATH = [
    [175, 119],
    [110, 70],
    [56, 133],
    [70, 481],
    [318, 731],
    [404, 680],
    [418, 521],
    [507, 475],
    [600, 551],
    [613, 715],
    [736, 713],
    [734, 399],
    [611, 357],
    [409, 343],
    [433, 257],
    [697, 258],
    [738, 123],
    [581, 71],
    [303, 78],
    [275, 377],
    [176, 388],
    [178, 260]
];

class GameInfo {
    static LEVELS = 10;

    constructor(level = 1) {
        this.level = level;
        this.started = false;
        this.levelStartTime = 0;
    }

    nextLevel() {
        this.level++;
        this.started = false;
    }

    reset() {
        this.level = 1;
        this.started = false;
        this.levelStartTime = 0;
    }

    gameFinished() {
        return this.level > this.LEVELS;
    }

    startLevel() {
        this.started = true;
        this.levelStartTime = time.time();
    }

    getLevelTime() {
        if (!this.started) return 0;
        return Math.round(time.time() - this.levelStartTime);
    }
}

class AbstractCar {
    constructor(maxVel, rotationVel) {
        this.img = this.IMG;
        this.maxVel = maxVel;
        this.vel = 0;
        this.rotationVel = rotationVel;
        this.angle = 0;
        [this.x, this.y] = this.START_POS;
        this.acceleration = 0.1;
    }

    rotate(left = false, right = false) {
        if (left) this.angle += this.rotationVel;
        else if (right) this.angle -= this.rotationVel;
    }

    draw(win) {
        blitRotateCenter(win, this.img, [this.x, this.y], this.angle);
    }

    moveForward() {
        this.vel = Math.min(this.vel + this.acceleration, this.maxVel);
        this.move();
    }

    moveBackward() {
        this.vel = Math.max(this.vel - this.acceleration, -this.maxVel / 2);
        this.move();
    }

    move() {
        const radians = math.radians(this.angle);
        const vertical = math.cos(radians) * this.vel;
        const horizontal = math.sin(radians) * this.vel;
        this.y -= vertical;
        this.x -= horizontal;
    }

    collide(mask, x = 0, y = 0) {
        const carMask = pygame.mask.fromSurface(this.img);
        const offset = [parseInt(this.x - x), parseInt(this.y - y)];
        const poi = mask.overlap(carMask, offset);
        return poi;
    }

    reset() {
        [this.x, this.y] = this.START_POS;
        this.angle = 0;
        this.vel = 0;
    }
}

class PlayerCar extends AbstractCar {
    static IMG = GREEN_ROCKET;
    static START_POS = [180, 200];

    reduceSpeed() {
        this.vel = Math.max(this.vel - this.acceleration / 2, 0);
        this.move();
    }

    bounce() {
        this.vel = -this.vel;
        this.move();
    }
}

class ComputerCar extends AbstractCar {
    static IMG = ORANGE_ROCKET;
    static START_POS = [150, 200];

    constructor(maxVel, rotationVel, path = []) {
        super(maxVel, rotationVel);
        this.path = path;
        this.currentPoint = 0;
        this.vel = maxVel;
    }

    drawPoints(win) {
        for (const point of this.path) {
            pygame.draw.circle(win, [255, 0, 0], point, 5);
        }
    }

    draw(win) {
        super.draw(win);
        // this.drawPoints(win);
    }

    calculateAngle() {
        const [targetX, targetY] = this.path[this.currentPoint];
        const xDiff = targetX - this.x;
        const yDiff = targetY - this.y;
        let desiredRadianAngle;
        if (yDiff === 0) {
            desiredRadianAngle = Math.PI / 2;
        } else {
            desiredRadianAngle = Math.atan(xDiff / yDiff);
        }
        if (targetY > this.y) desiredRadianAngle += Math.PI;
        let differenceInAngle = this.angle - math.degrees(desiredRadianAngle);
        if (differenceInAngle >= 180) differenceInAngle -= 360;
        if (differenceInAngle > 0) {
            this.angle -= Math.min(this.rotationVel, Math.abs(differenceInAngle));
        } else {
            this.angle += Math.min(this.rotationVel, Math.abs(differenceInAngle));
        }
    }

    updatePathPoint() {
        const target = this.path[this.currentPoint];
        const rect = new pygame.Rect(this.x, this.y);
        if (rect.contains(target)) {
            this.currentPoint++;
            if (this.currentPoint >= this.path.length) this.currentPoint = 0;
        }
    }
}
    </script>
    </section>

    <section id="contact">
        <h2>Contact Me</h2>
        <p>You can reach me at <a href="mailto:poweredbydreams92@gmail.com">poweredbydreams92@gmail.com</a>, <a href="tel:720-290-8971">720-290-8971</a></p>
    </section>

    <footer>
        <p>&copy; 2024 Andrew Hensley</p>
    </footer>
</body>
</html>


