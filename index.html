<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sol-Hearts</title>
    <link rel="stylesheet" href="Sol-Hearts-Styles.css"> <!-- Link to custom CSS file for styling -->
    <style>
        /* Define any additional CSS styles for your canvas or other elements here */
        canvas {
            border: 1px solid black;
            display: block;
            margin: 0 auto; /* Center the canvas */
        }

        /* Center the PDF within its container */
        .pdf-container {
            width: 800px; /* Adjust the width as needed */
            height: 600px; /* Adjust the height as needed */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pdf-container iframe {
            width: 100%;
            height: 100%;
            display: block;
            margin: auto; /* Center the PDF within the container */
        }
    </style>
</head>
<body>
    
    <header>
        <h1>Sol-Hearts</h1>
        <nav>
            <ul>
                <li><a href="#design">Design Document</a></li>
                <li><a href="#game">Game</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <section id="design">
        <h2>Design Document</h2>
        <div class="pdf-container">
            <iframe src="Sol Hearts.pdf" title="Sol-Hearts" frameborder="0"></iframe>
        </div>
    </section>

    <section id="game">
        <h2>Game</h2>
        <!-- Canvas for the game -->
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </section>
<canvas id="gameCanvas"></canvas>

    <script>
        // JavaScript code here...

        class GameInfo {
            constructor(level = 1) {
                this.level = level;
                this.started = false;
                this.levelStartTime = 0;
            }

            nextLevel() {
                this.level++;
                this.started = false;
            }

            reset() {
                this.level = 1;
                this.started = false;
                this.levelStartTime = 0;
            }

            gameFinished() {
                return this.level > this.LEVELS;
            }

            startLevel() {
                this.started = true;
                this.levelStartTime = time.time();
            }

            getLevelTime() {
                if (!this.started) return 0;
                return Math.round(time.time() - this.levelStartTime);
            }
        }

        class AbstractCar {
            constructor(maxVel, rotationVel) {
                this.img = this.IMG;
                this.maxVel = maxVel;
                this.vel = 0;
                this.rotationVel = rotationVel;
                this.angle = 0;
                [this.x, this.y] = this.START_POS;
                this.acceleration = 0.1;
            }

            rotate(left = false, right = false) {
                if (left) {
                    this.angle += this.rotationVel;
                } else if (right) {
                    this.angle -= this.rotationVel;
                }
            }

            draw(win) {
                blitRotateCenter(win, this.img, [this.x, this.y], this.angle);
            }

            moveForward() {
                this.vel = Math.min(this.vel + this.acceleration, this.maxVel);
                this.move();
            }

            moveBackward() {
                this.vel = Math.max(this.vel - this.acceleration, -this.maxVel / 2);
                this.move();
            }

            move() {
                const radians = Math.radians(this.angle);
                const vertical = Math.cos(radians) * this.vel;
                const horizontal = Math.sin(radians) * this.vel;
                this.y -= vertical;
                this.x -= horizontal;
            }

            collide(mask, x = 0, y = 0) {
                const carMask = pygame.mask.from_surface(this.img);
                const offset = [parseInt(this.x - x), parseInt(this.y - y)];
                const poi = mask.overlap(carMask, offset);
                return poi;
            }

            reset() {
                [this.x, this.y] = this.START_POS;
                this.angle = 0;
                this.vel = 0;
            }
        }

        class PlayerCar extends AbstractCar {
            constructor() {
                super(10, 4);
            }

            reduceSpeed() {
                this.vel = Math.max(this.vel - this.acceleration / 2, 0);
                this.move();
            }

            bounce() {
                this.vel = -this.vel;
                this.move();
            }
        }

        class ComputerCar extends AbstractCar {
            constructor(maxVel, rotationVel, path = []) {
                super(maxVel, rotationVel);
                this.path = path;
                this.currentPoint = 0;
                this.vel = maxVel;
            }

            drawPoints(win) {
                for (const point of this.path) {
                    pygame.draw.circle(win, [255, 0, 0], point, 5);
                }
            }

            draw(win) {
                super.draw(win);
                // this.drawPoints(win);
            }

            calculateAngle() {
                const [targetX, targetY] = this.path[this.currentPoint];
                const xDiff = targetX - this.x;
                const yDiff = targetY - this.y;
                let desiredRadianAngle = 0;
                if (yDiff === 0) {
                    desiredRadianAngle = Math.PI / 2;
                } else {
                    desiredRadianAngle = Math.atan(xDiff / yDiff);
                }
                if (targetY > this.y) {
                    desiredRadianAngle += Math.PI;
                }
                const differenceInAngle = this.angle - Math.degrees(desiredRadianAngle);
                if (differenceInAngle >= 180) {
                    differenceInAngle -= 360;
                }
                if (differenceInAngle > 0) {
                    this.angle -= Math.min(this.rotationVel, Math.abs(differenceInAngle));
                } else {
                    this.angle += Math.min(this.rotationVel, Math.abs(differenceInAngle));
                }
            }

            updatePathPoint() {
                const target = this.path[this.currentPoint];
                const rect = new pygame.Rect(this.x, this.y, this.img.width, this.img.height);
                if (rect.collidepoint(target)) {
                    this.currentPoint++;
                }
            }
        }

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // Define image URLs
        const SPACE = new Image();
        SPACE.src = "imgs/space.jpg";
        SPACE.onload = () => {
            canvas.width = SPACE.width;
            canvas.height = SPACE.height;
            draw();
        };

        const TRACK = new Image();
        TRACK.src = "imgs/track.png";
        TRACK.onload = () => {
            draw();
        };

        const FINISH = new Image();
        FINISH.src = "imgs/finish.png";
        FINISH.onload = () => {
            draw();
        };

        const GREEN_ROCKET = new Image();
        GREEN_ROCKET.src = "imgs/green-rocket.png";
        GREEN_ROCKET.onload = () => {
            draw();
        };

        const ORANGE_ROCKET = new Image();
        ORANGE_ROCKET.src = "imgs/orange-rocket.png";
        ORANGE_ROCKET.onload = () => {
            draw();
        };

        const MAIN_FONT = "44px sans-serif"; // Fixed the typo

        // Game logic variables
        const gameInfo = new GameInfo();

        const FPS = 60; // Frames per second
        const frameDelay = 1000 / FPS; // Delay between frames in milliseconds
        let lastFrameTime = 0;

        const playerCar = new PlayerCar();
        const computerCar = new ComputerCar(5, 3, PATH);
        let pathIndex = 0;

        function draw() {
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the background and other static elements
            ctx.drawImage(SPACE, 0, 0, SPACE.width, SPACE.height);

            // Scale and draw the track
            ctx.drawImage(TRACK, 0, 0, TRACK.width, TRACK.height);

            // Draw the finish line
            ctx.drawImage(FINISH, FINISH_POSITION[0], FINISH_POSITION[1], FINISH.width, FINISH.height);

            // Draw player's car
            ctx.drawImage(GREEN_ROCKET, playerCar.x, playerCar.y, GREEN_ROCKET.width, GREEN_ROCKET.height);

            // Draw computer's car
            ctx.drawImage(ORANGE_ROCKET, computerCar.x, computerCar.y, ORANGE_ROCKET.width, ORANGE_ROCKET.height);
        }

        // Main game loop
        function gameLoop(currentTime) {
            // Calculate time difference since the last frame
            const deltaTime = currentTime - lastFrameTime;

            // Check if it's time to update the frame
            if (deltaTime > frameDelay) {
                // Update the last frame time
                lastFrameTime = currentTime - (deltaTime % frameDelay);

                // Update game logic
                moveComputerCar(); // Move the computer-controlled car

                // Redraw the canvas with updated positions
                draw();
            }

            // Request the next frame
            requestAnimationFrame(gameLoop);
        }

        // Start the game loop
        requestAnimationFrame(gameLoop);

        // Add event listener for keyboard input to control player's car
        document.addEventListener("keydown", handleKeyDown);

        function handleKeyDown(event) {
            // Example: varied keys control the player's car movement
            switch (event.key) {
                case "w":
                    // Move forward
                    movePlayerCar(playerCar.vel);
                    break;
                case "d":
                    // Move backward (optional)
                    movePlayerCar(-playerCar.vel / 2); // Reduce speed when moving backward
                    break;
                case "k":
                    // Rotate left
                    playerCar.angle -= 5; // Adjust rotation angle as needed
                    break;
                case "l":
                    // Rotate right
                    playerCar.angle += 5; // Adjust rotation angle as needed
                    break;
                default:
                    break;
            }
        }

        function movePlayerCar(velocity) {
            // Calculate new position based on velocity and angle
            playerCar.x += velocity * Math.sin(playerCar.angle * Math.PI / 180);
            playerCar.y -= velocity * Math.cos(playerCar.angle * Math.PI / 180);

            // Optional: Implement boundary checking to keep the car within the track
            // Example: Check if the new position is within the canvas boundaries

            // Redraw the canvas with the updated positions
            draw();
        }

        function moveComputerCar() {
            if (pathIndex < PATH.length) {
                const targetX = PATH[pathIndex].x;
                const targetY = PATH[pathIndex].y;

                // Calculate angle to target
                const deltaX = targetX - computerCar.x;
                const deltaY = targetY - computerCar.y;
                const angleToTarget = Math.atan2(deltaY, deltaX) * (180 / Math.PI);

                // Move the car towards the target
                computerCar.angle = angleToTarget;
                computerCar.x += Math.cos(angleToTarget * Math.PI / 180) * computerCar.vel;
                computerCar.y += Math.sin(angleToTarget * Math.PI / 180) * computerCar.vel;

                // Check if the car has reached the target
                if (Math.abs(computerCar.x - targetX) < 5 && Math.abs(computerCar.y - targetY) < 5) {
                    pathIndex++;
                }
            }

            // Redraw the canvas with the updated positions
            draw();
        }
    </script>

    <footer id="contact">
        <h2>Contact</h2>
        <p>Contact us at solhearts@example.com</p>
    </footer>
</body>
</html>

           
